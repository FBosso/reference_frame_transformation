'@author Francesco Bosso'# import section -------------------------------------------------------------import numpy as np  from math import cos, sin, atan2, sqrtimport math as m# functions section ----------------------------------------------------------# INPUT: floatdef sessadec2sessages(ang_sessadec, string):    grad = ang_sessadec//1    prim = ((ang_sessadec - grad) * 60)//1    sec = round(((((ang_sessadec - grad) * 60) - ((ang_sessadec - grad) * 60)//1) *60),4)    sec = round(sec,4)    if string == True:        return f'{int(grad)}° {int(prim)}\' {sec}\'\''        #return '%d° %d\' %f\'\'' %(grad,prim,sec)    else:        return [grad,prim,sec]# OUTPUT: list#INPUT: listdef sessages2sessadec(list_g_p_s):    first = list_g_p_s[2]/60    second = (first + list_g_p_s[1])/60    last = second + list_g_p_s[0]    return last#OUTPUT: float# INPUT: (float, float, array or matrix)def GC2LC(lambda_origin_LC, phi_origin_LC, baseline_p_wrt_originLC):    l = lambda_origin_LC    p = phi_origin_LC    bl = baseline_p_wrt_originLC        Rz = np.matrix([[-sin(l),  cos(l), 0],                    [-cos(l), -sin(l), 0],                    [0,             0, 1]])        Rx = np.matrix([[1,      0,      0],                    [0, sin(p), cos(p)],                    [0, -cos(p),sin(p)]])        R = np.dot(Rx,Rz)    if type(bl) == np.ndarray:        ENU = np.dot(R,bl.T)        return ENU    elif type(bl) == np.matrix:        ENU = np.dot(R,bl)        return ENU    else:        print('ERROR: provided baseline is neither array or matrix ')    # OUTPUT: array or matrix# INPUT: (float, float, array or matrix, array)def LC2GC(lambda_origin_LC, phi_origin_LC, baseline_p_wrt_originLC, coord_origin_LC_in_GC_only_coord_trasformation, covariance=False, geodetic=False, inv=False):    l = lambda_origin_LC    p = phi_origin_LC    bl = baseline_p_wrt_originLC    x_p0 = np.matrix(coord_origin_LC_in_GC_only_coord_trasformation).T        Rz = np.matrix([[-sin(l),  cos(l), 0],                    [-cos(l), -sin(l), 0],                    [0,             0, 1]])        Rx = np.matrix([[1,       0,      0],                    [0,  sin(p), cos(p)],                    [0, -cos(p), sin(p)]])        R = np.dot(Rx,Rz)    if covariance == False:        if type(bl) == np.ndarray:            XYZ = np.dot(R.T,bl.T) + x_p0            return XYZ        elif type(bl) == np.matrix:            XYZ = np.dot(R.T,bl) + x_p0            return XYZ        else:            print('ERROR: provided baseline is neither array or matrix ')    elif covariance == True:        C_GC = np.dot(np.dot(R, baseline_p_wrt_originLC),R.T)        if geodetic == False:            return C_GC        elif geodetic == True:            if inv == False:                C_lam_phi_h = np.dot(np.dot(R.T, baseline_p_wrt_originLC),R)                return C_lam_phi_h            elif inv == True:                C_lam_phi_h = np.dot(np.dot(R, baseline_p_wrt_originLC),R.T)                return C_lam_phi_h            # OUTPUT: array or matrix# INPUT: (array or matrix, float, float, float)def LC2LL(xLC, alpha, csi, eta):        Rx = np.matrix([[1,        0,         0],                    [0, cos(csi), -sin(csi)],                    [0, sin(csi), cos(csi)]])        Ry = np.matrix([[cos(eta), 0, -sin(eta)],                    [       0, 1,         0],                    [sin(eta), 0, cos(eta)]])        Rz = np.matrix([[ cos(alpha), sin(alpha), 0],                    [-sin(alpha), cos(alpha), 0],                    [          0,          0, 1]])        R = np.dot(np.dot(Rz,Ry),Rx)    if type(xLC) == np.ndarray:        LL_coord = np.dot(R,xLC.T)        return LL_coord    elif type(xLC) == np.matrix:        LL_coord = np.dot(R,xLC)        return LL_coord    else:        print('ERROR: provided baseline is neither array or matrix ')#OUTPUT: array or matrix# INPUT: (array or matrix, float, float, float)def LL2LC(xLL, alpha, csi, eta, covariance=False):    Rx = np.matrix([[1,        0,         0],                    [0, cos(csi), -sin(csi)],                    [0, sin(csi), cos(csi)]])        Ry = np.matrix([[cos(eta), 0, -sin(eta)],                    [       0, 1,         0],                    [sin(eta), 0, cos(eta)]])        Rz = np.matrix([[ cos(alpha), sin(alpha), 0],                    [-sin(alpha), cos(alpha), 0],                    [          0,          0, 1]])        R = np.dot(np.dot(Rz,Ry),Rx)            if covariance == False:               if type(xLL) == np.ndarray:            LC_coord = np.dot(R.T,xLL.T)            return LC_coord        elif type(xLL) == np.matrix:            LC_coord = np.dot(R.T,xLL)            return LC_coord        else:            print('ERROR: provided baseline is neither array or matrix ')                elif covariance == True:        C_LC = np.dot(np.dot(R,xLL),R.T)        return C_LC        #OUTPUT: array or matrix# INPUT: (array, float, float)def alpha (x_shared_p_LC, csi, eta):         Rx = np.matrix([[1,   0,    0],                    [0,   1, -csi],                    [0, csi,    1]])        Ry = np.matrix([[  1, 0, -eta],                    [  0, 1,    0],                    [eta, 0,    1]])         R = np.dot(Ry,Rx)    x_temp = np.dot(R,x_shared_p_LC.T)    alpha = atan2(x_temp[1,0],x_temp[0,0])    return alpha#OUTPUT: float# INPUT: arraydef xyz2geo(xyz):        a=6378137.0000000    f=1/(298.25722210882711243)    b      = a*(1-f)    e_2    = 1-(1-f)**2    e_b_2  = 1/((1-f)**2) -1    r      =sqrt( m.pow(xyz[0],2) +m.pow(xyz[1],2) )    psi    =atan2( xyz[2] ,  r*m.sqrt(1-e_2))    lam    =atan2( xyz[1] , xyz[0])    phi    =atan2( xyz[2]+e_b_2*b*m.pow(sin(psi),3)  , r-e_2*a*m.pow(m.cos(psi),3))    R_n    = a/(sqrt(1-e_2*m.pow(m.sin(phi),2)))    h      = r/cos(phi) - R_n        geo=np.array([phi,lam,h])    return geo# INPUT: array# INPUT: arraydef xyz2geo_2(xyz):    lam = atan2(xyz[1],xyz[0])        a=6378137.0000000    e = sqrt(1-(1-1/(298.25722210882711243))**2)        k = 2    phi = 0    phi_app = 1    h = 0        while round(phi,20) != round(phi_app,20):        phi_app = phi        k = k-1        if k == 1:            n = (xyz[2])            d = sqrt(xyz[0]**2 + xyz[1]**2)            phi = atan2(n,d)            N =(a)/sqrt(1-(e**2 * (sin(phi))**2))                   else:            n = (xyz[2] + e**2 * (N*sin(phi)))            d = sqrt(xyz[0]**2 + xyz[1]**2)            phi = atan2(n,d)            N =(a)/sqrt(1-(e**2 * (sin(phi))**2))            h = (sqrt(xyz[0]**2 + xyz[1]**2)/(cos(phi)))- N        return np.array([phi,lam,h])#OUTPUT: array# INPUT: (array, float, float, arra)def linear_propagation(x_t0, t, t0, vel):    final = x_t0 + ((t-t0) * vel)    return final#OUTPUT: array# INPUT: (array, float, float, arra)def linear_propagation_covariance(C_t0, t, t0, Cv):    final = C_t0 + ((t-t0)**(2) * Cv)    return final#OUTPUT: array 