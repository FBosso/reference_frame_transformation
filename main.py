'@author Francesco Bosso'# import section -------------------------------------------------------------import numpy as npfrom functions import sessages2sessadec, sessadec2sessages, linear_propagation, linear_propagation_covariance, alpha, GC2LC, xyz2geo_2, xyz2geo, LL2LC, LC2GCfrom math import pi# input section --------------------------------------------------------------bl_cb_ITRF = np.array([-1040.168,-72.970,1631.398])bl_b1_ITRF = np.array([-51.130,76.749,38.681])b_LL  = np.array([0,0,0]) #originp1_LL = np.array([99.9994, 0.0, 1.0174]) #define x axisp2_LL = np.array([80.0, 85.0, 2.0])p3_LL = np.array([-25.0, 10.0, -3.0])csi = [0,0,10.23]eta = [0,0,9.5]# covariances of comoC_c_t0 = np.matrix([[0.001**2,     0,      0],                    [    0, 0.001**2,      0],                    [    0,     0,  0.001**2]])Cv_c   =  np.matrix([[0.0001**2,      0,       0],                    [      0, 0.0001**2,       0],                    [      0,      0,  0.0001**2]])# covariances of baseline como - brunC_Dx_cb = np.matrix([[  2*10**(-6), 0.5*10**(-6), 0.5*10**(-6)],                     [0.5*10**(-6),   1*10**(-6), 0.5*10**(-6)],                     [0.5*10**(-6), 0.5*10**(-6),   2*10**(-6)]])# covariances of baseline brun - p1C_Dx_b1 = np.matrix([[1.5*10**(-6), 0.3*10**(-6), 0.3*10**(-6)],                     [0.3*10**(-6),   1*10**(-6), 0.2*10**(-6)],                     [0.3*10**(-6), 0.2*10**(-6),   2*10**(-6)]])# covariances of p2 and p3C_p2_LL = np.matrix([[0.1**2,      0,       0],                     [     0, 0.1**2,       0],                     [     0,      0, 0.15**2]])C_p3_LL = C_p2_LL# preliminar computation section ---------------------------------------------c_ITRF_t0 = np.array([4398306.209, 704149.948, 4550154.733])t = 2019 + (31 + 2)/365t0 = 2010vel = np.array([-0.0145,  0.0181,  0.0113])c_ITRF_t = linear_propagation(c_ITRF_t0, t, t0, vel)# computations of coordintates -----------------------------------------------# conversion of csi and eta sessages -> sessadec -> radcsi = sessages2sessadec(csi) * pi/180eta = sessages2sessadec(eta) * pi/180# computation of BRUN in ITRF (GC)b_ITRF = c_ITRF_t + bl_cb_ITRF# computation of p1 in ITRF (GC) *****p1_ITRF = b_ITRF + bl_b1_ITRF# phi, lam, h of BRUN are needed in order to compute XYZ -> ENUb_GC_geodetic = xyz2geo(b_ITRF)# computation of baseline ITRF btw BRUN and p1bl_b1_ITRF = p1_ITRF - b_ITRF# computation of p1 in LCp1_LC = GC2LC(b_GC_geodetic[1], b_GC_geodetic[0], bl_b1_ITRF)# computation of alphaalpha = alpha(p1_LC, csi, eta)# computation of p1, p2, p3 in LC !!!p1??!!!xLL       = np.matrix([p1_LL,p2_LL,p3_LL]).Tp1p2p3_LC = LL2LC(xLL, alpha, csi, eta)p1p2p3_GC = LC2GC(b_GC_geodetic[1], b_GC_geodetic[0], p1p2p3_LC, b_ITRF)# data from EPN websiteb_ETRF  = np.array([4397266.34090, 704076.59220, 4551785.90180])p1_ETRF = np.array([4397215.21090, 704153.34120, 4551824.58280])#p1_ETRF = np.array([4397215.21090, 704153.34120, 4551824.58290])p2_ETRF = np.array([4397183.09030, 704084.32870, 4551867.37880])p3_ETRF = np.array([4397272.15620, 704050.77350, 4551780.10730])# computation of geodetic coordinatesb_ETRF_geo =  list(xyz2geo(b_ETRF))p1_ETRF_geo = list(xyz2geo(p1_ETRF))p2_ETRF_geo = list(xyz2geo(p2_ETRF))p3_ETRF_geo = list(xyz2geo(p3_ETRF))app = [b_ETRF_geo, p1_ETRF_geo, p2_ETRF_geo, p3_ETRF_geo]# conversion of phi and lambda from rad to degfor i in range(len(app)):    for j in range(len(app[1])):        if j != 2:            app[i][j] = app[i][j] * 180/pi            #rounding hfor i in range(len(app)):    app[i][2] = f'{round(app[i][2],3)} m'      # conversion of phi and lambda form sessadec to sessagesfor i in range(len(app)):    for j in range(len(app[0])):        if j != 2:            app[i][j] = sessadec2sessages(app[i][j], string = True)            # print of resultsprint('\n**********************************************************************************************')print('\nPRINT OF THE COORDINATES RESULTS AS LIST')print('\nBRUN_ETRF_geod (phi, lam, h) = ',app[0])print('\n0001_ETRF_geod (phi, lam, h) = ',app[1])print('\n0002_ETRF_geod (phi, lam, h) = ',app[2])print('\n0003_ETRF_geod (phi, lam, h) = ',app[3])print('\n**********************************************************************************************')# better data visualization - !! panda is required !!# if pandas is not installed comment from here (line 126) to line 131import pandas as pdprint('\nPRINT OF THE COORDINATES RESULTS AS DATAFRAME')df = pd.DataFrame(app, columns=['phi','lambda','h'], index=['BRUN_ETRF_geod','0001_ETRF_geod','0002_ETRF_geod','0003_ETRF_geod'])print('\n',df)print('\n**********************************************************************************************')# computations of covariances -----------------------------------------------C_c = linear_propagation_covariance(C_c_t0, t, t0, Cv_c)C_b = C_c + C_Dx_cbC_p1 = C_b + C_Dx_b1# computation of covariances of p2 and p3 from LL to LCC_Dx_p2b_LC = LL2LC(C_p2_LL, alpha, csi, eta, covariance=True)C_Dx_p3b_LC = C_Dx_p2b_LC# computation of covariances of p2 and p3 from LC to GCC_Dx_p2b_GC = LC2GC(b_GC_geodetic[1], b_GC_geodetic[0], C_Dx_p2b_LC, None, covariance=True)C_Dx_p3b_GC = C_Dx_p2b_GC# computation of covariances of p2 and p3 from LC to GCC_p2_GC = C_Dx_p2b_GC + C_bC_p3_GC = C_p2_GC# computation of the convaricances of all the points for geodetic coordinatesC_b_geod  = LC2GC(b_GC_geodetic[1], b_GC_geodetic[0], C_b, None, covariance=True, geodetic=True, inv=True)C_p1_geod = LC2GC(b_GC_geodetic[1], b_GC_geodetic[0], C_p1, None, covariance=True, geodetic=True, inv=True)C_p2_geod = LC2GC(b_GC_geodetic[1], b_GC_geodetic[0], C_p2_GC, None, covariance=True, geodetic=True)C_p3_geod = LC2GC(b_GC_geodetic[1], b_GC_geodetic[0], C_p3_GC, None, covariance=True, geodetic=True)print('\nPRINT OF THE DEV STD RESULTS AS LINES [m]')ENU = ['E','N','U']print('\n---- dev_std_BRUN ----\n')for i in range(3):    for j in range(3):        if i == j:            print(f'dev_std_BRUN_{ENU[i]} = {round(np.sqrt(C_b_geod[i,j]),4)}')            print('\n---- dev_std_p1 ----\n')for i in range(3):    for j in range(3):        if i == j:            print(f'dev_std_p1_{ENU[i]} = {round(np.sqrt(C_p1_geod[i,j]),4)}')            print('\n---- dev_std_p2 ----\n')for i in range(3):    for j in range(3):        if i == j:            print(f'dev_std_p2_{ENU[i]} = {round(np.sqrt(C_p2_geod[i,j]),3)}')            print('\n---- dev_std_p3 ----\n')for i in range(3):    for j in range(3):        if i == j:            print(f'dev_std_p3_{ENU[i]} = {round(np.sqrt(C_p3_geod[i,j]),3)}')print('\n**********************************************************************************************')                # better data visualization - !! panda is required !!# if pandas is not installed comment from here (line 189) to line 220            C_BRUN = []            for i in range(3):    for j in range(3):        if i == j:            C_BRUN.append(round(np.sqrt(C_b_geod[i,j]),4))            C_p1 = []for i in range(3):    for j in range(3):        if i == j:            C_p1.append(round(np.sqrt(C_p1_geod[i,j]),4))            C_p2 = []for i in range(3):    for j in range(3):        if i == j:            C_p2.append(round(np.sqrt(C_p2_geod[i,j]),3))            C_p3 = []for i in range(3):    for j in range(3):        if i == j:            C_p3.append(round(np.sqrt(C_p3_geod[i,j]),3))         tot = [C_BRUN, C_p1, C_p2, C_p3]df = pd.DataFrame(tot,columns=['E','N','U'], index=['dev_std_BRUN','dev_std_p1','dev_std_p2','dev_std_p3'])print('\nPRINT OF THE DEV STD RESULTS AS DATAFRAME [m]')print(df)print('\n**********************************************************************************************')           